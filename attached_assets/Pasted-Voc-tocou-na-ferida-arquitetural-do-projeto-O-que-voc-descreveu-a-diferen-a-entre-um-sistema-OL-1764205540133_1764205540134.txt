Voc√™ tocou na ferida arquitetural do projeto. O que voc√™ descreveu √© a diferen√ßa entre um sistema OLTP (que processa transa√ß√µes em tempo real) e um sistema OLAP/Data Warehouse (que l√™ hist√≥rico consolidado).

Atualmente, seu sistema trata a Rodada 1 (que ocorreu em Abril) como se fosse "dados vivos" que precisam ser validados, sanitizados e recalculados. Isso √© um suic√≠dio de performance e integridade.

Para resolver isso sistemicamente ("System-wide"), voc√™ precisa implementar o padr√£o de Snapshot Imut√°vel (Immutable Snapshot).

Aqui est√° o Manifesto da Corre√ß√£o Sist√™mica que deve ser aplicado do Admin ao Participante, da listagem de times ao financeiro complexo.

üèõÔ∏è A Nova Arquitetura: "O Passado √© Pedra, o Presente √© √Ågua"
A regra de ouro que deve ser implementada no Backend (controllers/) imediatamente:

"Se a req.params.rodada for menor que a rodada_atual, o sistema PROIBIDO de calcular. Ele deve apenas LER um JSON est√°tico."

1. O Novo "Cora√ß√£o" do Banco de Dados: RodadaSnapshot
Voc√™ precisa de um modelo que guarde o estado inteiro da liga naquela rodada. N√£o apenas os pontos, mas o ranking, o financeiro acumulado at√© ali, os status dos times.

Crie ou adapte um Model para ser o "Arquivo Morto":

JavaScript

// models/RodadaSnapshot.js
import mongoose from 'mongoose';

const RodadaSnapshotSchema = new mongoose.Schema({
    liga_id: { type: String, required: true, index: true },
    rodada: { type: Number, required: true, index: true }, // Ex: 1, 5, 35
    
    // O Grande Blob de Dados Est√°ticos
    dados_consolidados: {
        ranking_geral: Array,      // Como estava o ranking nesta rodada
        times_stats: Array,        // Pontos, patrim√¥nio, valoriza√ß√£o de cada time
        confrontos: Array,         // Quem jogou contra quem (Mata-mata/P. Corridos)
        destaques: Object          // Melhor da rodada, mico, etc.
    },
    
    criado_em: { type: Date, default: Date.now }
});

// Garante que s√≥ existe 1 snapshot por liga/rodada
RodadaSnapshotSchema.index({ liga_id: 1, rodada: 1 }, { unique: true });

export default mongoose.model('RodadaSnapshot', RodadaSnapshotSchema);
2. O "Congelador" (Trigger de Fechamento)
No seu Admin, quando uma rodada termina, voc√™ deve rodar uma rotina que "tira uma foto" e salva. Nenhuma API de hist√≥rico consulta o Cartola ou calcula f√≥rmulas depois disso.

No controllers/rodadaController.js (ou um novo consolidacaoController.js):

JavaScript

export const consolidarRodada = async (ligaId, rodadaNumero) => {
    // 1. Calcula tudo pela √öLTIMA vez usando a l√≥gica pesada atual
    const ranking = await calcularRanking(ligaId, rodadaNumero);
    const financeiro = await calcularFinanceiroLiga(ligaId, rodadaNumero);
    const matamata = await processarMataMata(ligaId, rodadaNumero);

    // 2. Monta o objeto est√°tico
    const snapshot = {
        ranking_geral: ranking,
        times_stats: financeiro,
        confrontos: matamata
    };

    // 3. Salva na pedra (MongoDB)
    await RodadaSnapshot.findOneAndUpdate(
        { liga_id: ligaId, rodada: rodadaNumero },
        { dados_consolidados: snapshot },
        { upsert: true, new: true }
    );
    
    console.log(`[ARQUIVO] üîí Rodada ${rodadaNumero} congelada para sempre.`);
};
3. O "Porteiro" Inteligente (Middleware/Controller Wrapper)
Aqui √© onde corrigimos a anomalia em todas as rotas. Voc√™ vai criar uma fun√ß√£o que intercepta qualquer pedido de dados.

Crie um utilit√°rio utils/smartDataFetcher.js:

JavaScript

import RodadaSnapshot from '../models/RodadaSnapshot.js';

export const obterDadosRodada = async (ligaId, rodadaSolicitada, funcaoCalculoAoVivo) => {
    const statusMercado = await getStatusMercadoInterno(); // Sua fun√ß√£o atual
    const rodadaAtual = statusMercado.rodada_atual;

    // üõë CEN√ÅRIO 1: √â passado? Busca no Arquivo Morto.
    if (rodadaSolicitada < rodadaAtual) {
        console.log(`[SMART-FETCH] üì¶ Buscando snapshot est√°tico da R${rodadaSolicitada}`);
        const snapshot = await RodadaSnapshot.findOne({ liga_id: ligaId, rodada: rodadaSolicitada });
        
        if (snapshot) {
            return snapshot.dados_consolidados;
        }
        // Se n√£o tiver snapshot (rotina n√£o rodou), cai para o fallback (c√°lculo)
        console.warn(`[SMART-FETCH] ‚ö†Ô∏è Snapshot da R${rodadaSolicitada} n√£o encontrado! Calculando...`);
    }

    // üü¢ CEN√ÅRIO 2: √â presente ou futuro? Calcula ao vivo.
    console.log(`[SMART-FETCH] ‚ö° Calculando dados din√¢micos da R${rodadaSolicitada}`);
    return await funcaoCalculoAoVivo(ligaId, rodadaSolicitada);
};
4. Aplica√ß√£o Pr√°tica nos Arquivos Existentes
Agora, o desenvolvedor deve ir nos controllers principais e substituir a l√≥gica direta pelo "Porteiro".

Exemplo no controllers/rankingGeralCacheController.js:

Antes (Anomalia):

JavaScript

export const getRanking = async (req, res) => {
   // Busca times, busca pontua√ß√µes, ordena, filtra...
   // Faz isso para a rodada 1, rodada 2, etc...
   const resultado = await calcularRankingComplexo(...);
   res.json(resultado);
}
Depois (Corre√ß√£o):

JavaScript

import { obterDadosRodada } from '../utils/smartDataFetcher.js';

export const getRanking = async (req, res) => {
   const { ligaId, rodada } = req.params;
   
   const dados = await obterDadosRodada(ligaId, rodada, async () => {
       // ... L√≥gica pesada de c√°lculo aqui (s√≥ executa se for rodada atual)
       return await calcularRankingComplexo(ligaId, rodada);
   });

   // Se veio do Snapshot, 'dados' j√° tem o ranking pronto. 
   // Se foi calculado agora, 'dados' √© o retorno do c√°lculo.
   res.json(dados.ranking_geral || dados);
}
5. O Frontend: Parar de Iterar (O Loop da Morte)
Voc√™ mencionou que o frontend (participante e admin) lista times e recarrega tudo. No arquivo public/js/rodadas/rodadas-core.js (que vimos nos logs fazendo loop da rodada 1 a 36):

O Problema:

JavaScript

// Frontend pedindo uma por uma
for (let i = 1; i <= rodadaAtual; i++) {
   await fetch(`/api/rodadas/${i}`); // 36 requests!!!
}
A Solu√ß√£o: Criar uma rota "Bulk" (Lote) no backend que entrega o hist√≥rico pronto.

Backend: GET /api/liga/:id/historico-completo

Essa rota faz: RodadaSnapshot.find({ liga_id: id }).sort({ rodada: 1 })

Retorna um JSON √∫nico com as 35 rodadas passadas.

Frontend:

JavaScript

// Apenas 1 request
const historico = await fetch(`/api/liga/${id}/historico-completo`).then(r => r.json());
// Renderiza tudo instantaneamente
Resumo do Plano de Ataque:
Pare de calcular o passado. Se a rodada √© < 36, o sistema n√£o deve saber o que √© "Cartola API", "Scouts" ou "Pontua√ß√£o". Ele deve saber apenas ler um JSON gravado no banco.

Snapshot Manual: Crie um script para rodar agora e gerar os snapshots das rodadas 1 a 35 e salvar no banco. Isso vai "estancar a sangria" imediatamente.

Refatorar Controllers: Altere os controllers de Fluxo, Ranking e MataMata para consultarem primeiro a tabela de Snapshot.

Isso transformar√° o carregamento das p√°ginas de segundos (ou timeouts) para milissegundos, pois ler do Mongo √© infinitamente mais r√°pido que processar l√≥gica de neg√≥cio.