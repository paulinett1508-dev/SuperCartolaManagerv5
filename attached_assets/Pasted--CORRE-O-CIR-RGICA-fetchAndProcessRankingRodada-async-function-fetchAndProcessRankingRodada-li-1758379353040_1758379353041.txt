// CORRE√á√ÉO CIR√öRGICA - fetchAndProcessRankingRodada
async function fetchAndProcessRankingRodada(ligaId, rodadaNum) {
  try {
    let fetchFunc;
    if (isBackend) {
      fetchFunc = (await import("node-fetch")).default;
    } else {
      fetchFunc = fetch;
    }

    const baseUrl = isBackend ? "http://localhost:3000" : "";
    
    // üîß CORRE√á√ÉO 1: Testar m√∫ltiplos endpoints
    const endpoints = [
      `${baseUrl}/api/rodadas/${ligaId}/rodadas?inicio=${rodadaNum}&fim=${rodadaNum}`,
      `${baseUrl}/api/ligas/${ligaId}/rodadas?rodada=${rodadaNum}`,
      `${baseUrl}/api/ligas/${ligaId}/ranking/${rodadaNum}`
    ];

    let rankingsDataFromApi = null;
    let lastError = null;

    // Tentar endpoints at√© encontrar dados
    for (const endpoint of endpoints) {
      try {
        console.log(`üîç [RODADAS] Tentando endpoint: ${endpoint}`);
        const resRodadas = await fetchFunc(endpoint);

        if (!resRodadas.ok) {
          console.warn(`‚ö†Ô∏è [RODADAS] Endpoint ${endpoint} retornou ${resRodadas.status}`);
          continue;
        }

        const data = await resRodadas.json();
        
        if (data && (Array.isArray(data) ? data.length > 0 : Object.keys(data).length > 0)) {
          rankingsDataFromApi = data;
          console.log(`‚úÖ [RODADAS] Dados encontrados no endpoint: ${endpoint}`);
          break;
        }
      } catch (err) {
        lastError = err;
        console.warn(`‚ö†Ô∏è [RODADAS] Erro no endpoint ${endpoint}:`, err.message);
        continue;
      }
    }

    if (!rankingsDataFromApi) {
      // üîß CORRE√á√ÉO 2: Verificar se rodada ainda n√£o tem dados ou se houve erro real
      const { rodada_atual, status_mercado } = statusMercadoGlobal;
      
      if (rodadaNum > rodada_atual) {
        console.log(`üìÖ [RODADAS] Rodada ${rodadaNum} √© futura (atual: ${rodada_atual})`);
        return [];
      } else if (rodadaNum === rodada_atual && status_mercado === 1) {
        console.log(`‚è∞ [RODADAS] Rodada ${rodadaNum} est√° em andamento - mercado aberto`);
        return [];
      } else {
        console.error(`‚ùå [RODADAS] Nenhum endpoint retornou dados para rodada ${rodadaNum}`);
        throw lastError || new Error(`Dados n√£o encontrados para rodada ${rodadaNum} em nenhum endpoint`);
      }
    }

    // üîß CORRE√á√ÉO 3: Normalizar estrutura de dados
    const dataArray = Array.isArray(rankingsDataFromApi) ? rankingsDataFromApi : [rankingsDataFromApi];

    if (dataArray.length === 0) {
      console.warn(`üìä [RODADAS] Dados vazios confirmados para rodada ${rodadaNum}`);
      return [];
    }

    // üîß CORRE√á√ÉO 4: Filtro mais robusto
    const rankingsDaRodada = dataArray.filter((rank) => {
      if (!rank || typeof rank !== "object") {
        console.warn(`‚ö†Ô∏è [RODADAS] Item inv√°lido encontrado:`, rank);
        return false;
      }
      
      if (!rank.hasOwnProperty("rodada")) {
        console.warn(`‚ö†Ô∏è [RODADAS] Item sem propriedade 'rodada':`, rank);
        return false;
      }

      const rodadaItem = parseInt(rank.rodada);
      const rodadaTarget = parseInt(rodadaNum);
      
      return rodadaItem === rodadaTarget;
    });

    // üîß CORRE√á√ÉO 5: Log detalhado para debug
    console.log(`üìà [RODADAS] Processamento rodada ${rodadaNum}:`);
    console.log(`   - Dados brutos: ${dataArray.length} items`);
    console.log(`   - Ap√≥s filtro: ${rankingsDaRodada.length} items`);
    console.log(`   - Rodadas √∫nicas nos dados:`, [...new Set(dataArray.map(r => r.rodada))]);

    // Ordenar por pontos
    rankingsDaRodada.sort(
      (a, b) => parseFloat(b.pontos || 0) - parseFloat(a.pontos || 0),
    );

    return rankingsDaRodada;
    
  } catch (err) {
    console.error(`‚ùå [RODADAS] Erro cr√≠tico em fetchAndProcessRankingRodada(${rodadaNum}):`, err);
    
    // üîß CORRE√á√ÉO 6: Retorno gracioso em caso de erro
    const { rodada_atual } = statusMercadoGlobal;
    if (rodadaNum <= rodada_atual) {
      // Para rodadas que deveriam ter dados, re-throw do erro
      throw new Error(`Falha ao carregar dados da rodada ${rodadaNum}: ${err.message}`);
    } else {
      // Para rodadas futuras, retornar array vazio
      return [];
    }
  }
}