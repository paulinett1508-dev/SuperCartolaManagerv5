// TOP10.JS - M√ìDULO DE MITOS E MICOS v2.0
// ‚úÖ v2.0: Fix rodada 38 (CAMPEONATO_ENCERRADO)
// ‚úÖ Usando imports din√¢micos para compatibilidade com rodadas.js

// ============================================================================
// ‚öΩ CONFIGURA√á√ÉO DO CAMPEONATO 2025
// ============================================================================
const RODADA_FINAL_CAMPEONATO = 38; // √öltima rodada do Brasileir√£o 2025
const CAMPEONATO_ENCERRADO = true; // Flag: temporada finalizada

// ==============================
// VARI√ÅVEIS GLOBAIS E DE ESTADO
// ==============================
let todosOsMitos = [];
let todosOsMicos = [];

// ==============================
// FUN√á√ïES DE IMPORTA√á√ÉO DIN√ÇMICA
// ==============================

/**
 * Obt√©m fun√ß√£o getRankingRodadaEspecifica de forma segura
 */
async function getRankingRodadaEspecifica(ligaId, rodadaNum) {
    // Tentar via window primeiro (mais r√°pido)
    if (window.rodadasDebug?.getRankingRodadaEspecifica) {
        return await window.rodadasDebug.getRankingRodadaEspecifica(
            ligaId,
            rodadaNum,
        );
    }

    // Fallback: import din√¢mico
    try {
        const rodadasModule = await import("./rodadas.js");
        if (rodadasModule.getRankingRodadaEspecifica) {
            return await rodadasModule.getRankingRodadaEspecifica(
                ligaId,
                rodadaNum,
            );
        }
    } catch (error) {
        console.warn("[TOP10] Erro ao importar rodadas:", error);
    }

    // Fallback final: API direta
    try {
        const response = await fetch(
            `/api/rodadas/${ligaId}/rodadas?inicio=${rodadaNum}&fim=${rodadaNum}`,
        );
        if (response.ok) {
            const data = await response.json();
            return Array.isArray(data)
                ? data.filter((r) => parseInt(r.rodada) === parseInt(rodadaNum))
                : [];
        }
    } catch (error) {
        console.error("[TOP10] Erro ao buscar rodada:", error);
    }

    return [];
}

/**
 * Obt√©m status do mercado
 */
async function getMercadoStatus() {
    try {
        const res = await fetch("/api/cartola/mercado/status");
        if (!res.ok) throw new Error("Erro ao buscar status do mercado");
        return await res.json();
    } catch (err) {
        console.error("[TOP10] Erro ao buscar status do mercado:", err);
        return { rodada_atual: RODADA_FINAL_CAMPEONATO, status_mercado: 2 };
    }
}

/**
 * Obt√©m ID da liga
 */
function obterLigaId() {
    // Verificar modo participante primeiro
    if (window.participanteData && window.participanteData.ligaId) {
        return window.participanteData.ligaId;
    }
    // Fallback para modo admin (URL)
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get("id") || urlParams.get("ligaId");
}

// ==============================
// SISTEMA DE CACHE UNIFICADO
// ==============================

/**
 * Tenta buscar o snapshot pronto do servidor
 */
async function lerCacheTop10(ligaId, rodada) {
    try {
        const ts = new Date().getTime();
        const response = await fetch(
            `/api/top10/cache/${ligaId}?rodada=${rodada}&_=${ts}`,
        );

        if (!response.ok) return null;

        const data = await response.json();
        if (data.cached && data.mitos && data.micos) {
            // ‚úÖ Validar se o cache est√° na rodada esperada
            if (data.rodada === rodada) {
                // ‚úÖ CORRE√á√ÉO: Verificar se arrays t√™m dados
                if (data.mitos.length === 0 || data.micos.length === 0) {
                    console.log(
                        `[TOP10] ‚ö†Ô∏è Cache VAZIO: arrays sem dados, recalculando...`,
                    );
                    return null;
                }

                // ‚úÖ CORRE√á√ÉO: Validar se os itens t√™m a propriedade 'rodada'
                const mitosValidos = data.mitos.every(
                    (item) =>
                        item.rodada !== undefined &&
                        item.nome_cartola !== undefined &&
                        item.pontos !== undefined,
                );
                const micosValidos = data.micos.every(
                    (item) =>
                        item.rodada !== undefined &&
                        item.nome_cartola !== undefined &&
                        item.pontos !== undefined,
                );

                if (!mitosValidos || !micosValidos) {
                    console.log(
                        `[TOP10] ‚ö†Ô∏è Cache CORROMPIDO: dados incompletos, recalculando...`,
                    );
                    return null;
                }

                console.log(
                    `[TOP10] üíæ Cache V√ÅLIDO encontrado para Rodada ${rodada} (${data.mitos.length} mitos, ${data.micos.length} micos)`,
                );
                return { mitos: data.mitos, micos: data.micos };
            } else {
                console.log(
                    `[TOP10] ‚ö†Ô∏è Cache DESATUALIZADO: esperava R${rodada}, tinha R${data.rodada}`,
                );
                return null;
            }
        }
        return null;
    } catch (error) {
        console.warn(
            "[TOP10] Falha ao ler cache (prosseguindo com c√°lculo):",
            error,
        );
        return null;
    }
}

/**
 * Salva o resultado do c√°lculo para o futuro
 */
async function salvarCacheTop10(ligaId, rodada, mitos, micos) {
    try {
        // ‚úÖ Determinar se √© cache permanente (rodada consolidada)
        const status = await getMercadoStatus();
        const isPermanent =
            CAMPEONATO_ENCERRADO || (status && status.rodada_atual > rodada);

        const response = await fetch(`/api/top10/cache/${ligaId}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                rodada: rodada,
                mitos: mitos,
                micos: micos,
                permanent: isPermanent,
            }),
        });

        if (response.ok) {
            const msg = isPermanent
                ? `[TOP10] üíæ Cache PERMANENTE salvo (Rodada ${rodada} consolidada)`
                : `[TOP10] üíæ Cache tempor√°rio salvo (Rodada ${rodada})`;
            console.log(msg);
        } else {
            console.warn(
                `[TOP10] ‚ùå Falha ao salvar cache: Servidor respondeu ${response.status}`,
            );
        }
    } catch (error) {
        console.warn("[TOP10] ‚ùå Erro de conex√£o ao salvar cache:", error);
    }
}

// ==============================
// CONFIGURA√á√ïES
// ==============================
const valoresBonusOnusPadrao = {
    mitos: {
        1: 30,
        2: 28,
        3: 26,
        4: 24,
        5: 22,
        6: 20,
        7: 18,
        8: 16,
        9: 14,
        10: 12,
    },
    micos: {
        1: -30,
        2: -28,
        3: -26,
        4: -24,
        5: -22,
        6: -20,
        7: -18,
        8: -16,
        9: -14,
        10: -12,
    },
};

const valoresBonusOnusCartoleirosSobral = {
    mitos: { 1: 10, 2: 9, 3: 8, 4: 7, 5: 6, 6: 5, 7: 4, 8: 3, 9: 2, 10: 1 },
    micos: {
        1: -10,
        2: -9,
        3: -8,
        4: -7,
        5: -6,
        6: -5,
        7: -4,
        8: -3,
        9: -2,
        10: -1,
    },
};

// ==============================
// INICIALIZA√á√ÉO
// ==============================
export async function inicializarTop10() {
    console.log("[TOP10] Inicializando m√≥dulo...");
    const loadingIndicator = document.getElementById("loadingTop10");
    if (loadingIndicator) loadingIndicator.style.display = "block";

    try {
        await carregarDadosTop10();
        await renderizarTabelasTop10();
    } catch (error) {
        console.error("[TOP10] Erro na inicializa√ß√£o:", error);
        renderizarErro("Erro ao carregar dados do Top 10");
    } finally {
        if (loadingIndicator) loadingIndicator.style.display = "none";
    }
}

// ==============================
// CARREGAMENTO DE DADOS (OTIMIZADO)
// ==============================
async function carregarDadosTop10() {
    console.log("[TOP10] Carregando dados...");

    // 1. Obter ID da Liga
    let ligaId = null;
    if (window.orquestrador?.ligaId) ligaId = window.orquestrador.ligaId;
    if (!ligaId) ligaId = obterLigaId();
    if (!ligaId && window.participanteData?.ligaId)
        ligaId = window.participanteData.ligaId;

    if (!ligaId) throw new Error("ID da Liga n√£o encontrado");
    console.log(`[TOP10] ‚úÖ Liga ID obtido: ${ligaId}`);

    todosOsMitos = [];
    todosOsMicos = [];

    try {
        const status = await getMercadoStatus();
        if (!status || !status.rodada_atual)
            throw new Error("N√£o foi poss√≠vel obter a rodada atual");

        // ‚úÖ v2.0: FIX - Considerar CAMPEONATO_ENCERRADO
        let ultimaRodadaCompleta;

        if (CAMPEONATO_ENCERRADO) {
            // Campeonato encerrado: √∫ltima rodada = RODADA_FINAL_CAMPEONATO
            ultimaRodadaCompleta = RODADA_FINAL_CAMPEONATO;
            console.log(
                `[TOP10] üèÅ Campeonato ENCERRADO - usando rodada ${RODADA_FINAL_CAMPEONATO}`,
            );
        } else {
            // Campeonato em andamento: verificar mercado
            const mercadoAberto =
                status.mercado_aberto || status.status_mercado === 1;
            if (mercadoAberto) {
                ultimaRodadaCompleta = Math.max(1, status.rodada_atual - 1);
            } else {
                ultimaRodadaCompleta = status.rodada_atual;
            }
        }

        if (ultimaRodadaCompleta === 0) {
            console.log("[TOP10] Nenhuma rodada completa ainda.");
            return;
        }

        console.log(
            `[TOP10] üìä Calculando Top10 at√© rodada ${ultimaRodadaCompleta}`,
        );

        // ============================================================
        // üöÄ OTIMIZA√á√ÉO: Tentar ler do Cache primeiro
        // ============================================================
        const cache = await lerCacheTop10(ligaId, ultimaRodadaCompleta);

        if (cache) {
            todosOsMitos = cache.mitos;
            todosOsMicos = cache.micos;
            // Ordena√ß√£o de seguran√ßa
            todosOsMitos.sort((a, b) => b.pontos - a.pontos);
            todosOsMicos.sort((a, b) => a.pontos - b.pontos);
            return; // ‚ú® SUCESSO R√ÅPIDO: Sai da fun√ß√£o sem loops!
        }

        console.log(
            `[TOP10] ‚ö†Ô∏è Cache Miss. Iniciando c√°lculo hist√≥rico (1 at√© ${ultimaRodadaCompleta})...`,
        );

        // ============================================================
        // üê¢ LENTO: C√°lculo Hist√≥rico (S√≥ roda se n√£o tiver cache)
        // ============================================================
        const promises = [];
        for (let i = 1; i <= ultimaRodadaCompleta; i++) {
            promises.push(
                getRankingRodadaEspecifica(ligaId, i)
                    .then((ranking) => {
                        if (ranking && ranking.length > 0) {
                            const rankingOrdenado = ranking.sort(
                                (a, b) => b.pontos - a.pontos,
                            );

                            // Mito (Primeiro)
                            const mito = { ...rankingOrdenado[0], rodada: i };
                            todosOsMitos.push(mito);

                            // Mico (√öltimo)
                            const mico = {
                                ...rankingOrdenado[rankingOrdenado.length - 1],
                                rodada: i,
                            };
                            todosOsMicos.push(mico);
                        }
                    })
                    .catch((error) =>
                        console.warn(`[TOP10] Erro rodada ${i}:`, error),
                    ),
            );
        }

        await Promise.all(promises);

        // Ordenar listas finais
        todosOsMitos.sort((a, b) => b.pontos - a.pontos);
        todosOsMicos.sort((a, b) => a.pontos - b.pontos);

        // ============================================================
        // üíæ OTIMIZA√á√ÉO: Salvar o resultado para a pr√≥xima vez
        // ============================================================
        if (todosOsMitos.length > 0) {
            await salvarCacheTop10(
                ligaId,
                ultimaRodadaCompleta,
                todosOsMitos,
                todosOsMicos,
            );
        }

        console.log(
            `[TOP10] Dados calculados e salvos: ${todosOsMitos.length} mitos, ${todosOsMicos.length} micos`,
        );
    } catch (error) {
        console.error("[TOP10] Erro ao carregar dados:", error);
        throw error;
    }
}

// ==============================
// RENDERIZA√á√ÉO
// ==============================
async function renderizarTabelasTop10() {
    const containerMitos = document.getElementById("top10MitosTable");
    const containerMicos = document.getElementById("top10MicosTable");

    if (!containerMitos || !containerMicos) return;

    // Determinar valores de b√¥nus/√¥nus
    let ligaId = null;
    if (window.orquestrador?.ligaId) ligaId = window.orquestrador.ligaId;
    if (!ligaId) ligaId = obterLigaId();

    const isLigaCartoleirosSobral = ligaId === "684d821cf1a7ae16d1f89572";
    const valoresBonusOnus = isLigaCartoleirosSobral
        ? valoresBonusOnusCartoleirosSobral
        : valoresBonusOnusPadrao;

    // Renderizar
    containerMitos.innerHTML = gerarTabelaHTML(
        todosOsMitos.slice(0, 10),
        "mitos",
        valoresBonusOnus,
    );
    containerMicos.innerHTML = gerarTabelaHTML(
        todosOsMicos.slice(0, 10),
        "micos",
        valoresBonusOnus,
    );

    console.log("[TOP10] Tabelas renderizadas com sucesso");
}

function gerarTabelaHTML(dados, tipo, valoresBonusOnus) {
    if (!dados || dados.length === 0) {
        return `<div class="error-state"><p class="error-message">Nenhum dado dispon√≠vel para ${tipo}</p></div>`;
    }

    const corHeader = tipo === "mitos" ? "var(--success)" : "var(--danger)";
    const valoresBonus =
        tipo === "mitos" ? valoresBonusOnus.mitos : valoresBonusOnus.micos;

    return `
        <table class="tabela-top10">
            <thead style="background: linear-gradient(135deg, ${corHeader} 0%, ${tipo === "mitos" ? "#16a34a" : "#dc2626"} 100%);">
                <tr>
                    <th style="width: 40px;">Pos</th>
                    <th style="min-width: 120px; text-align: left;">Cartoleiro</th>
                    <th style="min-width: 100px; text-align: left;">Time</th>
                    <th style="width: 40px;">Escudo</th>
                    <th style="width: 70px;">Pontos</th>
                    <th style="width: 60px;">Rodada</th>
                    <th style="width: 70px;">${tipo === "mitos" ? "B√¥nus" : "√înus"}</th>
                </tr>
            </thead>
            <tbody>
                ${dados
                    .map((item, index) => {
                        const posicao = index + 1;
                        const valorBonus = valoresBonus[posicao] ?? 0;
                        const valorClass =
                            valorBonus >= 0
                                ? "valor-positivo"
                                : "valor-negativo";
                        const valorFormatado =
                            valorBonus >= 0
                                ? `+R$ ${valorBonus.toFixed(2)}`
                                : `-R$ ${Math.abs(valorBonus).toFixed(2)}`;
                        const rowClass =
                            posicao <= 3 ? `posicao-${posicao}` : "";

                        return `
                        <tr class="${rowClass}">
                            <td style="text-align: center; font-weight: 700;">
                                ${posicao === 1 ? (tipo === "mitos" ? '<span class="material-symbols-outlined" style="color: #ffd700;">crown</span>' : '<span class="material-symbols-outlined" style="color: #ef4444;">skull</span>') : posicao + "¬∫"}
                            </td>
                            <td style="text-align: left;">${item.nome_cartola || item.nome_cartoleiro || "N/D"}</td>
                            <td style="text-align: left;">${item.nome_time || "N/D"}</td>
                            <td style="text-align: center;">
                                ${item.clube_id ? `<img src="/escudos/${item.clube_id}.png" alt="" class="time-escudo" onerror="this.style.display='none'"/>` : "‚ù§Ô∏è"}
                            </td>
                            <td style="text-align: center;" class="pontos-destaque">${(item.pontos ?? 0).toFixed(2)}</td>
                            <td style="text-align: center;">R${item.rodada ?? "?"}</td>
                            <td style="text-align: center;" class="${valorClass}">${valorFormatado}</td>
                        </tr>`;
                    })
                    .join("")}
            </tbody>
        </table>
    `;
}

function renderizarErro(mensagem) {
    const containerMitos = document.getElementById("top10MitosTable");
    const containerMicos = document.getElementById("top10MicosTable");
    const erroHTML = `
        <div class="error-state">
            <p class="error-message">${mensagem}</p>
            <button onclick="window.orquestrador.executeAction('top10')" class="btn-voltar">Tentar Novamente</button>
        </div>`;
    if (containerMitos) containerMitos.innerHTML = erroHTML;
    if (containerMicos) containerMicos.innerHTML = erroHTML;
}

// ==============================
// EXPORTA√á√ïES DE COMPATIBILIDADE
// ==============================

export async function garantirDadosCarregados() {
    if (todosOsMitos.length > 0 && todosOsMicos.length > 0) {
        return {
            mitos: todosOsMitos.slice(0, 10),
            micos: todosOsMicos.slice(0, 10),
        };
    }
    try {
        await carregarDadosTop10();
        return {
            mitos: todosOsMitos.slice(0, 10),
            micos: todosOsMicos.slice(0, 10),
        };
    } catch (error) {
        console.error("[TOP10] Erro ao carregar dados:", error);
        return { mitos: [], micos: [] };
    }
}

export function getMitosData() {
    return todosOsMitos.slice(0, 10);
}

export function getMicosData() {
    return todosOsMicos.slice(0, 10);
}

export function getTop10Data() {
    return {
        mitos: todosOsMitos.slice(0, 10),
        micos: todosOsMicos.slice(0, 10),
    };
}

// Expor fun√ß√µes globalmente para compatibilidade
if (typeof window !== "undefined") {
    window.inicializarTop10 = inicializarTop10;
    window.getMitosData = getMitosData;
    window.getMicosData = getMicosData;
    window.getTop10Data = getTop10Data;
}

console.log("[TOP10] ‚úÖ M√≥dulo v2.0 carregado (fix rodada 38)");
