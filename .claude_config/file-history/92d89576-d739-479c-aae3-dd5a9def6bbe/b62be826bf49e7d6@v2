// =====================================================================
// RODADAS CACHE CONTROLLER v1.2 - SEGURO + FASES
// Sistema de rec√°lculo SEGURO - NUNCA deleta dados
// ‚úÖ v1.2: Suporte a fases (Cartoleiros Sobral: FASE1 R1-28, FASE2 R29-38)
// =====================================================================

import Rodada from "../models/Rodada.js";
import Liga from "../models/Liga.js";
import Time from "../models/Time.js";
import mongoose from "mongoose";

// Configura√ß√£o de valores financeiros por liga
const LIGAS_CONFIG = {
  SUPERCARTOLA: "684cb1c8af923da7c7df51de",
  CARTOLEIROS_SOBRAL: "684d821cf1a7ae16d1f89572",
};

const VALORES_BANCO = {
  [LIGAS_CONFIG.SUPERCARTOLA]: {
    1: 20.0,
    2: 19.0,
    3: 18.0,
    4: 17.0,
    5: 16.0,
    6: 15.0,
    7: 14.0,
    8: 13.0,
    9: 12.0,
    10: 11.0,
    11: 10.0,
    12: 0.0,
    13: 0.0,
    14: 0.0,
    15: 0.0,
    16: 0.0,
    17: 0.0,
    18: 0.0,
    19: 0.0,
    20: 0.0,
    21: 0.0,
    22: -10.0,
    23: -11.0,
    24: -12.0,
    25: -13.0,
    26: -14.0,
    27: -15.0,
    28: -16.0,
    29: -17.0,
    30: -18.0,
    31: -19.0,
    32: -20.0,
  },
};

// ‚úÖ v1.2: Valores por fase para Cartoleiros do Sobral
const CARTOLEIROS_SOBRAL_FASES = {
  rodadaTransicao: 29,
  // FASE 1 (R1-R28): 6 participantes
  fase1: { 1: 7.0, 2: 4.0, 3: 0.0, 4: -2.0, 5: -5.0, 6: -10.0 },
  // FASE 2 (R29-R38): 4 participantes
  fase2: { 1: 5.0, 2: 0.0, 3: 0.0, 4: -5.0 },
};

// ‚úÖ v1.2: Retorna valores corretos por liga E rodada
function getValoresBanco(ligaId, rodada = 38) {
  if (ligaId === LIGAS_CONFIG.CARTOLEIROS_SOBRAL) {
    if (rodada < CARTOLEIROS_SOBRAL_FASES.rodadaTransicao) {
      return CARTOLEIROS_SOBRAL_FASES.fase1;
    }
    return CARTOLEIROS_SOBRAL_FASES.fase2;
  }
  return VALORES_BANCO[ligaId] || VALORES_BANCO[LIGAS_CONFIG.SUPERCARTOLA];
}

function toLigaId(ligaId) {
  if (mongoose.Types.ObjectId.isValid(ligaId)) {
    return new mongoose.Types.ObjectId(ligaId);
  }
  return ligaId;
}

// =====================================================================
// RECALCULAR RODADAS - √öNICA FUN√á√ÉO PERMITIDA (APENAS ATUALIZA)
// =====================================================================
export const recalcularRodadas = async (req, res) => {
  try {
    const { ligaId } = req.params;
    const { rodadaInicio, rodadaFim } = req.body;

    console.log(
      `[RODADAS-CACHE] üîÑ Recalculando rodadas ${rodadaInicio} a ${rodadaFim} da liga ${ligaId}`,
    );

    // Valida√ß√µes
    if (!rodadaInicio || !rodadaFim) {
      return res.status(400).json({
        success: false,
        erro: "Par√¢metros rodadaInicio e rodadaFim s√£o obrigat√≥rios",
      });
    }

    const inicio = parseInt(rodadaInicio);
    const fim = parseInt(rodadaFim);

    if (inicio < 1 || fim > 38 || inicio > fim) {
      return res.status(400).json({
        success: false,
        erro: "Valores de rodada inv√°lidos (1-38)",
      });
    }

    // Buscar dados da liga
    const liga = await Liga.findById(toLigaId(ligaId)).lean();
    if (!liga) {
      return res.status(404).json({
        success: false,
        erro: "Liga n√£o encontrada",
      });
    }

    // ‚úÖ v1.2: Buscar status de todos os times da liga (da cole√ß√£o Time)
    let mapaDesistencia = {};
    if (liga.times && liga.times.length > 0) {
      const timesStatus = await Time.find(
        { id: { $in: liga.times } },
        { id: 1, ativo: 1, rodada_desistencia: 1 }
      ).lean();

      timesStatus.forEach((time) => {
        if (time.ativo === false && time.rodada_desistencia) {
          mapaDesistencia[time.id] = time.rodada_desistencia;
        }
      });

      console.log(`[RODADAS-CACHE] Mapa de desist√™ncias:`, mapaDesistencia);
    }

    let totalRecalculados = 0;
    let rodadasProcessadas = [];

    // Iterar sobre cada rodada
    for (let rodada = inicio; rodada <= fim; rodada++) {
      console.log(`[RODADAS-CACHE] üìä Processando rodada ${rodada}...`);

      // ‚úÖ v1.2: Obter valores corretos para esta rodada espec√≠fica
      const valoresBanco = getValoresBanco(ligaId, rodada);

      // Buscar documentos existentes desta rodada
      const documentosRodada = await Rodada.find({
        ligaId: toLigaId(ligaId),
        rodada,
      });

      if (documentosRodada.length === 0) {
        console.log(`[RODADAS-CACHE] ‚ö†Ô∏è Rodada ${rodada} sem dados - pulando`);
        rodadasProcessadas.push({
          rodada,
          status: "sem_dados",
          recalculados: 0,
        });
        continue;
      }

      // ‚úÖ v1.2: Enriquecer com status de ativo/inativo (usando mapa da cole√ß√£o Time)
      const timesComStatus = documentosRodada.map((doc) => {
        const rodadaDesistencia = mapaDesistencia[doc.timeId] || null;
        const ativoNestaRodada =
          !rodadaDesistencia || rodada < rodadaDesistencia;

        return {
          _id: doc._id,
          timeId: doc.timeId,
          pontos: doc.pontos,
          rodadaNaoJogada: doc.rodadaNaoJogada,
          nome_cartola: doc.nome_cartola,
          nome_time: doc.nome_time,
          escudo: doc.escudo,
          clube_id: doc.clube_id,
          escudo_time_do_coracao: doc.escudo_time_do_coracao,
          ativoNestaRodada,
        };
      });

      // Filtrar apenas ATIVOS nesta rodada
      const timesAtivos = timesComStatus.filter((t) => t.ativoNestaRodada);

      // Ordenar por pontos
      const timesOrdenados = [...timesAtivos].sort(
        (a, b) => (b.pontos || 0) - (a.pontos || 0),
      );

      // Recalcular posi√ß√µes e valores financeiros (APENAS ATUALIZA, N√ÉO DELETA)
      let recalculadosRodada = 0;
      for (let i = 0; i < timesOrdenados.length; i++) {
        const time = timesOrdenados[i];
        const posicao = i + 1;
        const valorFinanceiro = valoresBanco[posicao] || 0;

        await Rodada.findByIdAndUpdate(time._id, {
          posicao,
          valorFinanceiro,
          totalParticipantesAtivos: timesOrdenados.length,
        });

        recalculadosRodada++;
        totalRecalculados++;
      }

      rodadasProcessadas.push({
        rodada,
        status: "recalculado",
        ativos: timesOrdenados.length,
        total: documentosRodada.length,
        recalculados: recalculadosRodada,
      });

      console.log(
        `[RODADAS-CACHE] ‚úÖ Rodada ${rodada}: ${recalculadosRodada} registros recalculados`,
      );
    }

    res.json({
      success: true,
      message: `Rec√°lculo conclu√≠do com sucesso`,
      ligaId,
      rodadaInicio: inicio,
      rodadaFim: fim,
      totalRecalculados,
      rodadasProcessadas,
      participantesAtivos: liga.times.filter((t) => t.ativo !== false).length,
      participantesTotal: liga.times.length,
    });
  } catch (error) {
    console.error("[RODADAS-CACHE] ‚ùå Erro ao recalcular:", error);
    res.status(500).json({
      success: false,
      erro: error.message,
    });
  }
};

// =====================================================================
// ESTAT√çSTICAS
// =====================================================================
export const estatisticasCache = async (req, res) => {
  try {
    const { ligaId } = req.params;
    const filtroBase = ligaId ? { ligaId: toLigaId(ligaId) } : {};

    const total = await Rodada.countDocuments(filtroBase);

    const corrompidos = await Rodada.countDocuments({
      ...filtroBase,
      $or: [
        { posicao: { $exists: false } },
        { posicao: null },
        { valorFinanceiro: { $exists: false } },
      ],
    });

    const validos = total - corrompidos;

    let porRodada = null;
    if (ligaId) {
      const pipeline = [
        { $match: { ligaId: toLigaId(ligaId) } },
        { $group: { _id: "$rodada", count: { $sum: 1 } } },
        { $sort: { _id: 1 } },
      ];
      porRodada = await Rodada.aggregate(pipeline);
    }

    res.json({
      success: true,
      estatisticas: {
        total,
        validos,
        corrompidos,
        percentualValido:
          total > 0 ? ((validos / total) * 100).toFixed(1) + "%" : "0%",
        porRodada: porRodada || "dispon√≠vel apenas para liga espec√≠fica",
      },
    });
  } catch (error) {
    console.error("[RODADAS-CACHE] ‚ùå Erro ao obter estat√≠sticas:", error);
    res.status(500).json({
      success: false,
      erro: "Erro ao obter estat√≠sticas",
    });
  }
};

console.log(
  "[RODADAS-CACHE] ‚úÖ Controller v1.2 carregado (suporte a fases + busca Time)",
);
